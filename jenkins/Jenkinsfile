pipeline {
    agent any
    environment {
        AWS_REGION = 'us-east-1'
        ECR_REGISTRY = '148761635167.dkr.ecr.us-east-1.amazonaws.com'
        CLUSTER_NAME = "dev-devsecops-cluster"
        DOCKER_IMAGE = "${ECR_REGISTRY}/flask-test-app:${env.BUILD_ID}"

        // Check if EKS cluster exists
        EKS_EXISTS = sh(
            script: 'aws eks describe-cluster --name dev-devsecops-cluster --query "cluster.status" --output text 2>/dev/null | grep -q ACTIVE && echo true || echo false',
            returnStdout: true
        ).trim()
    }
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', 
                url: 'https://github.com/marksog/sample_flask_app.git',
                credentialsId: 'github-credentials'
                script {
                    env.BRANCH_NAME = 'main'
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    docker.build(DOCKER_IMAGE, "--build-arg ENVIRONMENT=${env.BRANCH_NAME} ./app")
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                script {
                    // Ensure ECR repository exists
                    sh """
                    aws ecr describe-repositories --repository-names flask-test-app || \
                    aws ecr create-repository --repository-name flask-test-app
                    """
                    
                    // Login to ECR
                    withAWS(credentials: 'AWS_ID', region: AWS_REGION) {
                        sh "aws ecr get-login-password | docker login --username AWS --password-stdin ${ECR_REGISTRY}"
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }
        
        stage('Deploy Infrastructure') {
            when {
                expression { return EKS_EXISTS == 'false' }
            }
            steps {
                dir('infra') {
                    withAWS(region: AWS_REGION, credentials: 'AWS_ID') {
                        sh '''
                        terraform init
                        terraform import module.jenkins.aws_security_group.jenkins sg-021371c9a04fd55fb || true 
                        terraform import module.jenkins.aws_iam_role.jenkins dev-jenkins-role || true
                        terraform plan
                        terraform apply -auto-approve
                        '''
                        script {
                            def clusterName = sh(
                                script: "terraform output -raw eks_cluster_name",
                                returnStdout: true
                            ).trim()
                            env.CLUSTER_NAME = clusterName
                            echo "EKS Cluster Name: ${env.CLUSTER_NAME}"
                        }
                    }
                }
            }
        }
        
        stage('Configure Kubernetes Access') {
            steps {
                script {
                    def clusterStatus = ''
                    timeout(time:10, unit: 'MINUTES') {
                        while (clusterStatus != 'ACTIVE') {
                            clusterStatus = sh(
                                script: "aws eks describe-cluster --name ${CLUSTER_NAME} --region ${AWS_REGION} --query 'cluster.status' --output text || echo 'NOT_FOUND'",
                                returnStdout: true
                            ).trim()
                            if (clusterStatus == 'NOT_FOUND') {
                                error "EKS cluster ${CLUSTER_NAME} not found. Please check the cluster name and region."
                            }
                            if (clusterStatus != 'ACTIVE') {
                                echo "Cluster status: ${clusterStatus}. Waiting for it to become ACTIVE..."
                                sleep(time: 30, unit: 'SECONDS')
                            }
                        }
                    }
                    sh '''
                        mkdir -p /var/lib/jenkins/.kube
                        chown -R jenkins:jenkins /var/lib/jenkins/.kube
                        chmod 700 /var/lib/jenkins/.kube
                    '''
                    sh "aws eks update-kubeconfig --name ${CLUSTER_NAME} --region ${AWS_REGION}"
                }
            }
        }
        
        stage('Deploy Application') {
            steps {
                script {
                    dir('infra/k8s/base') { // Navigate to the correct directory
                        sh "kubectl apply -f namespace.yaml"
                        sh "kubectl apply -f monitoring/prometheus-values.yaml"
                        sh "kubectl apply -f argo/applicationset.yaml"
                    }
                    
                    // Install Helm and deploy Prometheus
                    sh "kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -"
                    sh """
                    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                    helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
                        -n monitoring \
                        -f infra/k8s/base/monitoring/prometheus-values.yaml
                    """
                    
                    // Install ArgoCD
                    sh "kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -"
                    sh """
                    kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
                    """
                    
                    // Deploy environment-specific applications
                    dir("infra/k8s/${env.BRANCH_NAME}") {
                        sh "kubectl apply -f internal-app/"
                        sh "kubectl apply -f public-app/"
                    }
                }
            }
        }
        
        stage('Stress Testing') {
            steps {
                script {
                    def public_endpoint = sh(
                        script: "kubectl get svc public-service -n ${env.BRANCH_NAME} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'",
                        returnStdout: true
                    ).trim()
                    
                    def bastion_ip = sh(
                        script: "terraform output -state=infra/terraform.tfstate -raw bastion_public_ip",
                        returnStdout: true
                    ).trim()
                    
                    sh """
                    docker run --rm \
                        -v ${WORKSPACE}/jenkins/scripts:/scripts \
                        -e TARGET_URL=http://${public_endpoint} \
                        loadimpact/k6 run /scripts/stress-test-public.js
                    """
                    
                    sshagent(['bastion-ssh-key']) {
                        sh """
                        scp -o StrictHostKeyChecking=no \
                            jenkins/scripts/stress-test-internal.sh \
                            ec2-user@${bastion_ip}:/tmp/
                            
                        ssh -o StrictHostKeyChecking=no \
                            ec2-user@${bastion_ip} \
                            "chmod +x /tmp/stress-test-internal.sh && /tmp/stress-test-internal.sh"
                        """
                    }
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                script {
                    def public_url = sh(
                        script: "kubectl get svc public-service -n ${env.BRANCH_NAME} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'",
                        returnStdout: true
                    ).trim()
                    
                    sh "curl -s http://${public_url}/health | jq ."
                    sh "kubectl get pods -n ${env.BRANCH_NAME}"
                }
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            echo "✅ Pipeline SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        }
        failure {
            echo "❌ Pipeline FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
        }
    }
}